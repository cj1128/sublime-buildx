import json
import sublime
import sublime_plugin
import os
from string import Template
from .ansi import ANSIProcessor

target_view_name = "Build Output"
buildx_color_scheme = "Packages/User/BuildX/BuildX.sublime-color-scheme"
buildx_syntax = "Packages/BuildX/BuildX.sublime-syntax"

def get_setting(key):
  settings = sublime.load_settings("BuildX.sublime-settings")
  default_settings = json.load(open(os.path.join(os.path.dirname(__file__), "BuildX.sublime-settings")))

  return settings.get(key) or default_settings.get(key)

def gen_color_scheme():
  dir = os.path.join(sublime.packages_path(), "User", "BuildX")

  # create dir
  if not os.path.exists(dir):
      os.makedirs(dir)

  # generate color scheme file
  target_path = os.path.join(dir, "BuildX.sublime-color-scheme")

  color_scheme = get_color_scheme()
  with open(target_path, "w") as f:
    f.write(json.dumps(color_scheme, indent=2))

def get_color_scheme():
  ansi_color = get_setting("ansi_color")

  result = {
    "author": "Auto generated by BuildX",
    "name": "BuildX",
    "variables": {
      "bg": "%s" % ansi_color["bg"],
      "bg2": "color(var(bg) blend(red 50%) alpha(0.01))",
    },
    "globals": {
      "background": "var(bg)",
      "foreground": "%s" % ansi_color["fg"],
      "caret": "%s" % ansi_color["caret"],
      "gutter": "%s" % ansi_color["gutter"],
      "gutter_foreground": "%s" % ansi_color["gutter_foreground"],
      "invisibles": "%s" % ansi_color["invisibles"],
      "line_highlight": "%s" % ansi_color["line_highlight"],
      "selection": "%s" % ansi_color["selection"],
    },
    "rules": [],
  }

  # for ansi colors
  for color in ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]:
    for prefix in ["bright_", ""]:
      key = prefix + color
      result["rules"].append({
        "foreground": "%s" % ansi_color[key],
        "background": "var(bg2)",
        "scope": "%s" % key,
      })
      result["rules"].append({
        "foreground": "%s" % ansi_color[key],
        "background": "var(bg2)",
        "font_style": "bold",
        "scope": "%s.bold" % key,
      })

  # for syntax colors
  syntax_color = get_setting("syntax_color")

  for k, v in syntax_color.items():
    result["rules"].append({
      "foreground": v,
      "background": "var(bg2)",
      "scope": k,
    })

  return result

def plugin_loaded():
  settings = sublime.load_settings("BuildX.sublime-settings")
  settings.add_on_change("on_plugin_settings_change", gen_color_scheme)

  gen_color_scheme()

def plugin_unloaded():
  settings = sublime.load_settings("BuildX.sublime-settings")
  settings.clear_on_change("on_plugin_settings_change")

  for win in sublime.windows():
    for view in win.views():
      if view.name() == target_view_name:
        view.assign_syntax("scope:text.plain")
        view.settings().clear_on_change("on_view_settings_change")

def is_buildx_syntax(view):
  return view.settings().get("syntax") == buildx_syntax

class BuildX:
  def __init__(self):
    self.source_view = None
    self.window = None

    self.target_view = None
    self.build_inited = False
    self.source_last_pos = 0
    self.is_waiting = False
    self.regions = []
    self.ansi = ANSIProcessor()

  # this will be triggered even if we just move cursor in the view
  def on_view_settings_change(self, view):
    settings = view.settings()

    # we use 'final_syntax' field to know wheter syntax is changed
    if settings.get("syntax") == settings.get("final_syntax"):
      return

    settings.set("final_syntax", settings.get("syntax"))

    if is_buildx_syntax(view):
      view.settings().set("color_scheme", buildx_color_scheme)

      view.run_command("buildx_content_clear")

      source_content = self.source_view.substr(sublime.Region(0, self.source_view.size()))

      self.ansi.clear()
      self.ansi_process(view, source_content)
    else:
      # erase regions
      for key in self.regions:
        view.erase_regions(key)
      self.regions = []

      view.run_command("buildx_content_clear")

      # set to default color scheme
      view.settings().set("color_scheme", view.settings().get("origin_color_scheme"))

      source_content = self.source_view.substr(sublime.Region(0, self.source_view.size()))

      view.run_command("buildx_content_append", {"index": 0, "text": source_content})

  def get_target_view(self):
    if self.target_view is not None:
      return self.target_view

    # Find target view by name
    view = None
    for v in self.window.views():
      if v.name() == target_view_name:
        view = v
        break

    if view is None:
      # create a new view
      view = self.window.new_file()
      view.set_name(target_view_name)

    view.set_scratch(True)
    view.assign_syntax(buildx_syntax)

    settings = view.settings()
    settings.set("origin_color_scheme", settings.get("color_scheme"))
    settings.set("color_scheme", buildx_color_scheme)
    settings.add_on_change("on_view_settings_change", lambda: self.on_view_settings_change(view))

    self.target_view = view
    return view

  def on_build_start(self):
    self.build_inited = True
    window = self.window
    original_view = window.active_view()

    self.target_view = self.get_target_view()
    self.target_view.settings().set("translate_tabs_to_spaces", not get_setting("preserve_content"))

    # get_target_view will trigger 'on_view_settings_change' and
    # will invoke ansi_processor
    self.ansi.clear()

    # focus target view in other group
    if window.num_groups() > 1:
      group_index, index = window.get_view_index(self.target_view)

      # move target view to other group
      if group_index == window.active_group():
        target_group_index = (window.active_group() + 1) % window.num_groups()
        window.set_view_index(self.target_view, target_group_index, 0)

      # focus target view
      self.window.focus_view(self.target_view)

      # focus back
      self.window.focus_view(original_view)
    else:
      self.window.focus_view(original_view)

    self.target_view.run_command("buildx_content_clear")
    self.source_last_pos = 0

  def ansi_process(self, view, content):
    # used to cache group of 'char' type
    content_index = -1
    content_texts = []

    for item in self.ansi.process(content):
      (type, value) = item
      if type == "char":
        (index, char) = value
        if content_index == -1:
          content_index = index

        content_texts.append(char)

      if type == "region":
        if content_index != -1:
          view.run_command("buildx_content_append", {"index": content_index, "text": "".join(content_texts)})
          content_texts.clear()
          content_index = -1

        (start, end, color, bold) = value
        scope = "%s.bold" % color if bold else color
        region_key = str(start)
        self.regions.append(region_key)
        view.add_regions(region_key, [sublime.Region(start, end)], scope)

    if content_index != -1:
      view.run_command("buildx_content_append", {"index": content_index, "text": "".join(content_texts)})
      content_texts.clear()

  def pipe_text(self):
    self.is_waiting = False
    index = self.source_last_pos
    new_pos = self.source_view.size()
    region = sublime.Region(self.source_last_pos, new_pos)
    content = self.source_view.substr(region)
    self.source_last_pos = new_pos

    view = self.target_view

    if get_setting("process_ansi_color") == True and is_buildx_syntax(view):
      self.ansi_process(view, content)
    else:
      view.run_command("buildx_content_append", {"index": index, "text": content})

    # scroll to bottom
    self.target_view.show(view.size())

  def on_source_modified(self):
    if self.is_waiting:
      return

    if self.build_inited == False:
      self.on_build_start()

      # if build is very fast
      # we will see no change in build output
      # delay 100ms so that we can see the content is flashing
      self.is_waiting = True
      sublime.set_timeout(self.pipe_text, 100)
    else:
      self.pipe_text()

  # line-based highlighting
  def on_source_selection_modified(self):
    if len(self.source_view.sel()) == 0:
      return

    target = self.source_view.sel()[0]
    if target.a == target.b: # no selection
      return

    # both are 0-based
    line, _ = self.source_view.rowcol(target.a)

    start_point = self.target_view.text_point(line, 0)
    end_point = self.target_view.text_point(line + 1, 0) - 1
    sel = self.target_view.sel()
    sel.clear()
    sel.add(sublime.Region(start_point, end_point))

    # scroll to selection region
    self.target_view.show(start_point)

    # jump to target view and back to refresh selection
    origin = self.window.active_view()
    self.window.focus_view(self.target_view)
    self.window.focus_view(origin)

class BuildXListener(sublime_plugin.EventListener):
  def __init__(self):
    # each window has an exec output panel
    # exec output panel view -> buildx object
    self.buildx_map = {}

  # view is exec output panel view
  def get_buildx(self, view):
    if view is None:
      return None

    return self.buildx_map.get(view.id())

  def register_buildx(self, buildx, view):
    self.buildx_map[view.id()] = buildx

  def on_modified(self, view):
    buildx = self.get_buildx(view)
    if buildx is None:
      return

    if view.id() != buildx.source_view.id():
      return

    buildx.on_source_modified()

  def on_selection_modified(self, view):
    buildx = self.get_buildx(view)
    if buildx is None:
      return

    if view.id() != buildx.source_view.id():
      return

    buildx.on_source_selection_modified()

  def on_close(self, view):
    if view.name() != target_view_name:
      return

    for _, buildx in self.buildx_map.items():
      if buildx.target_view is None:
        continue

      if buildx.target_view.id() == view.id():
        buildx.target_view = None

  def on_query_context(self, view, key, *args):
    if key != "for_buildx":
      return None

    source_view = view.window().get_output_panel("exec")
    source_view.settings().set("translate_tabs_to_spaces", not get_setting("preserve_content"))

    buildx = self.get_buildx(source_view)
    if buildx is None:
      buildx = BuildX()
      buildx.source_view = source_view
      buildx.window = view.window()
      self.register_buildx(buildx, source_view)

    buildx.build_inited = False

    if get_setting("clear_output_when_build_starts"):
      sublime.set_timeout(buildx.on_build_start, 100)

    return True

class BuildxContentAppend(sublime_plugin.TextCommand):
  def run(self, edit, index, text):
    self.view.insert(edit, index, text)

class BuildxContentReplace(sublime_plugin.TextCommand):
  def run(self, edit, start, end, text):
    self.view.replace(edit, sublime.Region(start, end), text)

class BuildxContentClear(sublime_plugin.TextCommand):
  def run(self, edit):
    region = sublime.Region(0, self.view.size())
    self.view.erase(edit, region)
